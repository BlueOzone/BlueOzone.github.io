<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Redis集群(基础篇系列五) | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis集群(基础篇系列五)</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis集群(基础篇系列五)</h1><div class="post-meta">2020-09-20<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Redis集群概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">Redis集群方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-Cluster"><span class="toc-number">3.</span> <span class="toc-text">Redis Cluster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reids%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Reids集群实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%90%86%E8%AE%BA"><span class="toc-number">4.1.</span> <span class="toc-text">数据分布理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-number">4.2.</span> <span class="toc-text">Redis 集群数据的共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">Redis集群的主从复制模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.3.1.</span> <span class="toc-text">主从集群的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">Redis集群的数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8A%9F%E8%83%BD%E9%99%90%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">Redis集群的功能限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E5%A4%B1%E6%95%88"><span class="toc-number">4.6.</span> <span class="toc-text">Redis集群失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.</span> <span class="toc-text">Redis集群的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.2.</span> <span class="toc-text">集群的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">Redis集群总结</span></a></li></ol></div></div><div class="post-content"><p>Redis的集群的基础主从复制已经讲完啦，下面就来详细讲讲Redis的集群吧。本篇会介绍Redis集群的概述、集群的方案、原理以及不同方案的特点等。</p>
<span id="more"></span>

<h2 id="Redis集群概述"><a href="#Redis集群概述" class="headerlink" title="Redis集群概述"></a>Redis集群概述</h2><p>Redis 集群是一个可以<strong>在多个 Redis 节点之间进行数据共享</strong>的，由多个Redis节点组成的程序集。</p>
<h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><p><strong>Redis 有三种集群方案</strong>：</p>
<ul>
<li><strong>主从复制模式：</strong>主机数据更新后根据配置和策略，自动会以异步复制的方式，同步数据到备机的机制；但是这种方式，主节点的写和存储受到单机的限制； 在大型系统架构中可能还需要应用端自己实现数据分片的功能，而且发生故障的时候还需要人工手动恢复；所以这种方式现在基本被摈弃掉了，转而使用Redis官方推荐的Cluster模式。</li>
<li><strong>Sentinel（哨兵）模式：</strong>我们知道，Redis的主从复制模式下，发生故障的时候还是需要人工干预的。所以Redis从2.8开始，正式提供了Redis Sentinel（哨兵）架构来解决这个问题；Redis Sentinel能自动完成故障发现和故障转移， 并通知应用方，从而实现真正的高可用。</li>
<li><strong>Cluster 模式（官方推荐）：</strong>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，它采用了无中心结构、主从复制等技术，有效地解决了Redis分布式方面的需求。<strong>没有特殊说明的情况下，在本篇中Redis集群说的都是Redis Cluster模式，且本篇的Redis版本 &gt;= 3.0。</strong></li>
</ul>
<h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>Redis Cluster可以通过分区（partition）来提供一定程度的可用性<strong>（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</strong></p>
<p>总结来说，Redis 集群有以下两个功能：</p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li>
</ul>
<h2 id="Reids集群实现原理"><a href="#Reids集群实现原理" class="headerlink" title="Reids集群实现原理"></a>Reids集群实现原理</h2><p>Redis集群的自动切分数据跟数据分布理论有关；在分布式系统中，将数据分散到多个节点，一方面突破了单节点内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</p>
<h3 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h3><p>在分布式系统中，<strong>分布式数据库</strong>需要解决把<strong>整个数据集</strong>按照<strong>分区规则</strong>映射到<strong>多个节点</strong>的问题，即把<strong>数据集</strong>划分到<strong>多个节点</strong>上，每个节点负责<strong>整体数据</strong>的一个<strong>子集</strong>。</p>
<p>数据划分通常有<strong>哈希分区</strong>和<strong>顺序分区</strong>两种方式：</p>
<table>
<thead>
<tr>
<th>分区方式</th>
<th>特点</th>
<th>相关产品</th>
</tr>
</thead>
<tbody><tr>
<td>哈希分区</td>
<td>离散程度好，数据分布与业务无关，无法顺序访问</td>
<td>Redis Cluster，Cassandra，Dynamo</td>
</tr>
<tr>
<td>顺序分区</td>
<td>离散程度易倾斜，数据分布与业务相关，可以顺序访问</td>
<td>BigTable，HBase，Hypertable</td>
</tr>
</tbody></table>
<p>Redis集群采用的是<strong>哈希分区规则</strong>，常见的哈希分区有以下几种：</p>
<p>（1）<strong>节点取余分区：</strong>使用特定的数据，如Redis的键或用户ID，再根据节点（运行在集群模式下的Redis服务器）的数量N使用公式：<code>hash(key) % N</code>计算出hash值，用来决定数据存储在哪个节点上。<br>（2）<strong>一致性哈希分区：</strong>实现思路是为系统中的每个节点分配一个token，范围是<code>0~232-1</code>，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算出哈希值，然后顺时针找到第一个遇到的token节点。<br>（3）<strong>虚拟槽分区（Redis集群所采用的）：</strong>巧妙的使用了哈希空间，使用分散度良好的哈希函数将所有的数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，这是为了消除哈希的倾斜性，便于数据拆分和扩展。例如Redis Cluster槽的范围是<code>0~16383</code>。槽是集群内数据管理和迁移的基本单位，每个节点都会负责一定数量的槽。</p>
<h3 id="Redis-集群数据的共享"><a href="#Redis-集群数据的共享" class="headerlink" title="Redis 集群数据的共享"></a>Redis 集群数据的共享</h3><p>上面了解到Redis采用的是虚拟槽分区， 其中，一个 Redis 集群包含 <code>16384</code> 个哈希槽（hash slot）， 数据库中的每个键都属于这 <code>16384</code> 个哈希槽的其中一个， 集群会使用公式 <code>CRC16(key) % 16384</code> 来计算键 <code>key</code> 属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 CRC16 校验和。</p>
<p>集群中的每个主节点负责处理一部分哈希槽。 举个例子， 一个集群有三个哈希槽， 其中：</p>
<ul>
<li>节点 A 负责处理 <code>0</code> 号至 <code>5500</code> 号哈希槽。</li>
<li>节点 B 负责处理 <code>5501</code> 号至 <code>11000</code> 号哈希槽。</li>
<li>节点 C 负责处理 <code>11001</code> 号至 <code>16384</code> 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p>
<p>Redis虚拟槽分布的特点：</p>
<p>（1）解耦数据和节点之间的关系，简化了节点的扩容和收缩。<br>（2）节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。<br>（3）支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</p>
<h3 id="Redis集群的主从复制模型"><a href="#Redis集群的主从复制模型" class="headerlink" title="Redis集群的主从复制模型"></a>Redis集群的主从复制模型</h3><p>为了在主节点子集出现故障或无法与大多数节点通信时保持可用，Redis Cluster<strong>使用到了主从复制功能</strong>，也就是主从模型，其中每个哈希槽都具有从1（主节点master本身）到N个副本（N - 1个副本是从节点 slave）；Redis Cluster沿用了主从复制的大部分功能，所以主从复制功能对我们理解主从集群的实现过程是非常有帮助的，建议读者把主从复制啃得差不多了，再来仔细的理解主从集群的原理相关。</p>
<p>所以，现在Redis Cluster模式也会被称为<strong>主从集群</strong>。</p>
<p><strong>主从集群和主从复制的区别：</strong></p>
<p>（1）主从复制是Redis本身的一个功能，开始的时候是为了满足故障恢复和负载均衡等需求。<br>（2）主从集群是利用了Redis主从复制的功能，并结合了虚拟槽分区等技术，将多个Redis节点整合成一个整体对外的服务，可以解决单机内存、并发、流量等瓶颈，是Redis的分布式解决方案。</p>
<p>在主从集群中，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会自动启用从节点。</p>
<p>比如：当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机/下线了；此时就会将A节点的从节点A1提升为主节点，继续对外提供服务。由于主从节点维护的都是同样的虚拟槽，而且主从复制功能也保证了主从节点数据的大部分相同，所以在对客户正常使用基本是无感的。</p>
<p>如果主节点 A 和它的从节点 A1 都宕机了，此时该集群就无法再提供服务了。</p>
<h4 id="主从集群的特点"><a href="#主从集群的特点" class="headerlink" title="主从集群的特点"></a><strong>主从集群的特点</strong></h4><ul>
<li>每个节点都和n-1个节点通信，这被称为集群总线（cluster bus）。它们使用特殊的端口号进行通信，即对外服务端口号加10000，且内部使用二进制协议优化传输速度和带宽。</li>
<li>客户端与redis节点直连，不需要连接集群所有的节点，连接集群中任何一个可用节点即可。整个cluster被看做是一个整体，客户端可连接任意一个节点进行操作，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点。</li>
<li>采用无中心结构，每一个节点都保存有这个集群所有主节点以及从节点的信息，及集群状态，每个节点都和其他节点连接。所以Redis-cluster也是一种服务端分片技术。</li>
<li>为了增加集群的可访问性，官方推荐的方案是将节点配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为master节点，使得整个集群继续对外提供服务。</li>
</ul>
<h3 id="Redis集群的数据一致性"><a href="#Redis集群的数据一致性" class="headerlink" title="Redis集群的数据一致性"></a>Redis集群的数据一致性</h3><p>Redis 集群<strong>不保证数据的强一致性</strong>（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。主要有两个原因造成了这种情况：</p>
<p>（1）异步复制<br>Redis Cluster<strong>使用了主从复制模型</strong>，而主从复制中就用到了异步复制的功能。其实异步复制是Redis在性能和一致性上做的权衡，假如使用的是同步复制的话，主节点处理命令的速度会大大降低。</p>
<p>在这种情况下，由于异步复制， Redis 集群可能会丢失已经被执行过的写命令：</p>
<p>客户端向集群中的A节点(主节点)发送写<code>key1</code>的请求，A有一个从节点A1，A并不会等A1同步完后才回复客户端写入成功，而是自身处理完后直接回复给客户端。在A处理完写入的后，由于各种原因（A崩溃或网络中断）导致A与A1的部分复制未能成功；而A节点也与集群中的其他主节点通信失败，此时集群就会将A1升为主节点；而此时A1并没有写入<code>key1</code>，因为复制失败了，他并不知道A节点中已经发生了这件事情。此时客户端向集群再去查<code>key1</code>，查询不到，这样就会丢失已经被执行过的写命令。</p>
<p>（2）网络分裂<br>网络分裂导致丢失已经被执行过的写命令通常发生在Redis各个节点在不同的网络分区的情况下，不同的网络分区，也就导致了集群中各个节点可能通信不正常。</p>
<p>举个例子：<br>假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p>
<p>由于网络通信等原因，集群中发生网络分裂， 集群可能会分裂为两方， A 、C 、A1 、B1 和 C1 这五个节点在此时连接不上B，认为他们组成了一个集群；而实际上节点 B 和客户端 Z1 保持着正常的连接，并为客户端提供所有的服务。</p>
<p>在这个网络分裂期间， 主节点 B 仍然会接受客户端 Z1 发送的写命令：</p>
<ul>
<li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；随后写入节点 B 的数据也会照常复制给 B1 。</li>
<li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 在主节点 B 与集群通信失败期间，发送给 B 的写命令将丢失。</li>
</ul>
<p>在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的，这样就不会因为网络分裂而丢失太对“写成功”的数据， 这一时间限制称为<strong>节点超时时间</strong>（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>
<ul>
<li>对于拥有大多数节点的一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li>
<li>对于拥有少数节点的一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li>
</ul>
<h3 id="Redis集群的功能限制"><a href="#Redis集群的功能限制" class="headerlink" title="Redis集群的功能限制"></a>Redis集群的功能限制</h3><p>Redis 集群相对单机在功能上存在一些<strong>限制</strong>，需要开发人员提前了解，在使用时做好规避。</p>
<ul>
<li>key 批量操作支持有限。比如： <code>mset、mget</code> 操作，目前只支持对具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 <code>mset、mget</code> 等操作可能存在于多个节点上，因此不被支持。</li>
<li>key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。</li>
<li>key 作为数据分区的最小粒度，不能将一个大的键值对象如 hash、list 等映射到不同的节点。</li>
<li>不支持多数据库空间，单机下的Redis可以支持 16 个数据库（db0 ~ db15），<strong>集群模式下只能使用一个数据库空间</strong>，即 db0。</li>
<li>复制结构只支持一层，<strong>从节点只能复制主节点，不支持嵌套树状复制结构</strong>。</li>
<li><strong>Redis集群部署至少需要3个及3个以上的主节点</strong>。</li>
</ul>
<h3 id="Redis集群失效"><a href="#Redis集群失效" class="headerlink" title="Redis集群失效"></a>Redis集群失效</h3><p>在下面两种情况下，Redis集群会无法正常运行：</p>
<p>（1）某个主节点和他的所有从节点都挂了，可以理解为某个槽没有Redis节点进行维护了，集群就会无法正常运行。<br>（2）如果同时有一半以上的主节点宕机，那么无论这些节点有没有从节点，集群同样会无法正常运行。这就是Redis的投票机制。</p>
<h2 id="Redis集群的创建"><a href="#Redis集群的创建" class="headerlink" title="Redis集群的创建"></a>Redis集群的创建</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>使用Redis-Cluster集群，<strong>需要在配置文件配置<code>cluster-enabled yes</code>选项</strong>，否则创建集群会失败，报如下的错误：</p>
<p><code>[ERR] Node 10.100.1.238:34210 is not configured as a cluster node.</code></p>
<p>修改完后启动Redis实例。</p>
<h3 id="集群的创建"><a href="#集群的创建" class="headerlink" title="集群的创建"></a>集群的创建</h3><p>Redis的安装和启动这里就不说了，假设我们已经启好了六个正在运行的Redis示例（Redis版本是5.0.4），那么接下来我们来演示一下怎么使用这六个实例来创建一个Redis主从集群。</p>
<p>去到Redis的安装目录，通过<code>--cluster create</code>命令来创建，需要执行以下命令：<br><code>./src/redis-cli -a &#39;redis密码&#39; --cluster create 每个redis的ip+port，使用空格分隔 --cluster-replicas 0</code></p>
<p>比如，我输入的是：</p>
<p><code>./src/redis-cli -a &#39;passwd123&#39; --cluster create 10.100.1.238:34210 10.100.1.238:34211 10.100.1.238:34212 10.100.1.238:34213 10.100.1.238:34214 10.100.1.238:34215 --cluster-replicas 1</code></p>
<p><strong><code>--cluster-replicas 1</code>   相关说明：</strong></p>
<p>后面的数字代表为每个主节点分配对应个数的从节点；<br>如果你有6个节点，创建集群的时候填0，就会形成6个都是主节点的redis集群；<br>如果你有6个节点，创建集群的时候填1，就会形成3主3从的redis集群。</p>
<p>集群创建完毕后，进入某个节点，可以<code>cluster info</code>和<code>cluster nodes</code>命令查看到集群信息：</p>
<figure class="highlight plaintext"><figcaption><span>[root@brdev3 redis-5.0.4]# ./src/redis-cli -a 'passwd123' -c -p 34210</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@brdev3 redis-5.0.4]# ./src/redis-cli -a &#x27;passwd123&#x27; -c -p 34210</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:34210&gt; cluster nodes</span><br><span class="line">b9eb237114719e7dc1e9cfcba531097a775686ca 10.100.1.238:34211@44211 master - 0 1619342616000 2 connected 5461-10922</span><br><span class="line">ce8e5d0faf57353d77f334dba3b37537f9baa0ed 10.100.1.238:34212@44212 master - 0 1619342616952 3 connected 10923-16383</span><br><span class="line">da932172e9d29065a7f32c293ac91430bfbbf63f 10.100.1.238:34210@44210 myself,master - 0 1619342617000 1 connected 0-5460</span><br><span class="line">b502e293d82b27385abf98fce524d81ff3919463 10.100.1.238:34215@44215 slave ce8e5d0faf57353d77f334dba3b37537f9baa0ed 0 1619342617963 6 connected</span><br><span class="line">9b35b72b190f3bf731093b9cae36315277e78035 10.100.1.238:34213@44213 slave da932172e9d29065a7f32c293ac91430bfbbf63f 0 1619342616000 4 connected</span><br><span class="line">e23b09db0441efe088dc1e84b646a359f50b7dfd 10.100.1.238:34214@44214 slave b9eb237114719e7dc1e9cfcba531097a775686ca 0 1619342618970 5 connected</span><br><span class="line">127.0.0.1:34210&gt;</span><br><span class="line">127.0.0.1:34210&gt;</span><br><span class="line">127.0.0.1:34210&gt; cluster info</span><br><span class="line"># 集群状态，ok代表正常，fail代表不正常</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:142</span><br><span class="line">cluster_stats_messages_pong_sent:145</span><br><span class="line">cluster_stats_messages_sent:287</span><br><span class="line">cluster_stats_messages_ping_received:140</span><br><span class="line">cluster_stats_messages_pong_received:142</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:287</span><br><span class="line">127.0.0.1:34210&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Redis集群总结"><a href="#Redis集群总结" class="headerlink" title="Redis集群总结"></a>Redis集群总结</h2><p>网上看到有人说某个主节点挂掉后，Redis集群会把这个节点的槽分给其他主节点。这种说法是错误的，至少对于Redis-Cluster集群来说是非常不正确的。</p>
<p>前面有提到：<strong>某个槽没有Redis节点进行维护了，集群就会无法正常运行。</strong>这才是正确的，所以，在这个场景下，集群会进入失败状态：</p>
<p>5个主节点形成一个集群，随后关闭其中一个节点；随后查看集群的状态，会显示集群状态为<code>fail</code>，集群就会无法正常运行；并不会自动的将槽分配给其他节点。</p>
<p>Redis集群功能还是非常强大的，而且许多内部实现的细节我这里都没有讲到，如果全部细致的讲一遍的话可能连载个十几篇都说不完说不透；平常工作学习的还是要养成记笔记的习惯，把他写下来，理顺来，对形成记忆有不小的帮助。</p>
</div><div class="tags"><a href="/tags/Redis%E5%9F%BA%E7%A1%80/"><i class="fa fa-tag"></i>Redis基础</a></div><div class="post-nav"><a class="pre" href="/2020/10/15/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%80)/">Redis为什么那么快(高级篇系列一)</a><a class="next" href="/2020/09/14/Redis%E7%9A%84%E5%A4%8D%E5%88%B6(%E5%9F%BA%E7%A1%80%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis的复制(基础篇系列四)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis%E9%AB%98%E7%BA%A7/" style="font-size: 15px;">Redis高级</a> <a href="/tags/Redis%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Redis基础</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/" style="font-size: 15px;">等级保护</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/docker/">Docker的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis分布式锁(高级篇系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80(%E7%B3%BB%E5%88%97%E4%BA%94)/">JVM之对象的内存布局(系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA(%E7%B3%BB%E5%88%97%E5%9B%9B)/">JVM之方法区(系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM%E4%B9%8B%E5%A0%86(%E7%B3%BB%E5%88%97%E4%B8%89)/">JVM之堆(系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B(%E7%B3%BB%E5%88%97%E4%BA%8C)/">JVM之运行时数据区(系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F(%E7%B3%BB%E5%88%97%E4%B8%80)/">JVM之类加载子系统(系列一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/13/Python%E5%9C%A8Linux%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/">Python实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>