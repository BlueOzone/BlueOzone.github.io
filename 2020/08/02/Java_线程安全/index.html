<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java-线程安全 | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-线程安全</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-线程安全</h1><div class="post-meta">2020-08-02<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">保证线程安全的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">保证线程安全方式一：同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">保证线程安全方式二：同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">保证线程安全方式三：Lock 锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8ELock%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">synchronized与Lock的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">线程的死锁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">线程安全的单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p><strong>什么是线程安全？</strong></p>
<p>线程安全：不论什么情况下，多线程的执行结果都和单线程的执行结果保持一致；或者说一个对象不论怎样调用，都能得到正确的结果，那么这个对象就是线程安全的。</p>
<p>但是当多个线程访问同个一资源的时候，就会出现线程安全问题。比如售票系统，多个线程同时访问库存，如果没有做到线程的同步就很有可能会出现超卖（比如卖了-1这个号的票），或者重复卖（票号为2的卖了多次）的问题。</p>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>下面我们通过代码来详细了解一下上面说售票系统说的超卖和重复卖的问题：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> LockTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> <span class="constructor">Window()</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.set<span class="constructor">Name(<span class="string">&quot;窗口1&quot;</span>)</span>;</span><br><span class="line">        t2.set<span class="constructor">Name(<span class="string">&quot;窗口2&quot;</span>)</span>;</span><br><span class="line">        t3.set<span class="constructor">Name(<span class="string">&quot;窗口3&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.start<span class="literal">()</span>;</span><br><span class="line">        t2.start<span class="literal">()</span>;</span><br><span class="line">        t3.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Window implements Runnable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(e.get<span class="constructor">Message()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了三个线程，模拟了三个用户去抢票的过程，为了更好的出现超卖的问题，中间通过<code>Thread.sleep(100);</code>让线程睡眠了一段时间，以下是程序的运行结果，可以很明显的看到，几个客户都抢到了票号为10的票，而且有个客户还抢到了票号为-1的票，也就是上面说的重复卖和超卖的问题：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">窗口1：售票，票号为：10</span><br><span class="line">窗口2：售票，票号为：10</span><br><span class="line">窗口3：售票，票号为：8</span><br><span class="line">窗口1：售票，票号为：7</span><br><span class="line">窗口2：售票，票号为：7</span><br><span class="line">窗口3：售票，票号为：5</span><br><span class="line">窗口1：售票，票号为：4</span><br><span class="line">窗口2：售票，票号为：4</span><br><span class="line">窗口3：售票，票号为：2</span><br><span class="line">窗口2：售票，票号为：1</span><br><span class="line">窗口1：售票，票号为：1</span><br><span class="line">窗口3：售票，票号为：<span class="string">-1</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，为什么会出现重复卖和超卖的问题呢？<br>因为当某个线程操作车票的过程中，尚未操作完成时，其他的线程也参与进来，也操作车票。<br>那怎么解决这些问题呢？<br>当一个线程a操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</p>
<p>解决方案大都是通用的，下面我们来讲解一下一般情况下有什么方式去保证线程安全问题。</p>
<h2 id="保证线程安全的几种方式"><a href="#保证线程安全的几种方式" class="headerlink" title="保证线程安全的几种方式"></a>保证线程安全的几种方式</h2><p>一般有以下三种方式来保证线程安全：<br>保证线程安全方式一：同步代码块<br>保证线程安全方式二：同步方法<br>保证线程安全方式三：Lock 锁机制<br>下面我们来讲解一下这几种方式，以及他们在实现上有什么区别。</p>
<h2 id="保证线程安全方式一：同步代码块"><a href="#保证线程安全方式一：同步代码块" class="headerlink" title="保证线程安全方式一：同步代码块"></a>保证线程安全方式一：同步代码块</h2><p>同步代码块，即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步，保证线程安全。<br>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。<br>同步代码块示例如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (同步监视器)&#123;</span><br><span class="line">	<span class="regexp">//</span>需要被同步的代码(操作共享数据的代码)</span><br><span class="line">	<span class="regexp">//</span>共享数据：多个线程共同操作的变量</span><br><span class="line">	<span class="regexp">//</span>同步监视器：俗称为锁。任何一个类的对象都可以充当锁。多个线程必须共用一把锁。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通俗来说，被synchronized包裹的代码，同时最多只能被一个线程执行，当一个线程获取到同步监视器后，才能执行被包裹的代码；无法获得同步监视器的线程必须等待着其他线程执行完毕后释放（此时其他未抢到同步监视器处于阻塞状态），再去抢同步监视器；所以为了保证线程安全，多个线程必须共用一个同步监视器，也就锁，保证锁是一样的，才能保证线程安全。</p>
<p>同步代码块示例代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> LockTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> <span class="constructor">Window()</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.set<span class="constructor">Name(<span class="string">&quot;窗口1&quot;</span>)</span>;</span><br><span class="line">        t2.set<span class="constructor">Name(<span class="string">&quot;窗口2&quot;</span>)</span>;</span><br><span class="line">        t3.set<span class="constructor">Name(<span class="string">&quot;窗口3&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.start<span class="literal">()</span>;</span><br><span class="line">        t2.start<span class="literal">()</span>;</span><br><span class="line">        t3.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Window implements Runnable&#123;</span><br><span class="line">    <span class="built_in">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    final Object obj = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            synchronized (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;：售票，票号为 ：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">窗口2：售票，票号为 ：10</span><br><span class="line">窗口2：售票，票号为 ：9</span><br><span class="line">窗口3：售票，票号为 ：8</span><br><span class="line">窗口3：售票，票号为 ：7</span><br><span class="line">窗口3：售票，票号为 ：6</span><br><span class="line">窗口3：售票，票号为 ：5</span><br><span class="line">窗口3：售票，票号为 ：4</span><br><span class="line">窗口3：售票，票号为 ：3</span><br><span class="line">窗口3：售票，票号为 ：2</span><br><span class="line">窗口3：售票，票号为 ：1</span><br></pre></td></tr></table></figure>
<p>即使大家多执行几次，也不会看到超卖和重复卖的问题；在上面的代码中我们使用了synchronized同步代码块修饰了卖票的操作，使得每次只有一个线程在执行，保证了票号的线程安全。</p>
<h2 id="保证线程安全方式二：同步方法"><a href="#保证线程安全方式二：同步方法" class="headerlink" title="保证线程安全方式二：同步方法"></a>保证线程安全方式二：同步方法</h2><p>同步方法，即有synchronized关键字修饰的方法。<br>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。<br>synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。<br>synchronized修饰方法时，跟同步代码块相似，也使用到了锁的机制，只不过synchronized修饰方法时默认的锁是当前对象。</p>
<p>synchronized同步方法示例代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> LockTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> <span class="constructor">Window()</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">window</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.set<span class="constructor">Name(<span class="string">&quot;窗口1&quot;</span>)</span>;</span><br><span class="line">        t2.set<span class="constructor">Name(<span class="string">&quot;窗口2&quot;</span>)</span>;</span><br><span class="line">        t3.set<span class="constructor">Name(<span class="string">&quot;窗口3&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.start<span class="literal">()</span>;</span><br><span class="line">        t2.start<span class="literal">()</span>;</span><br><span class="line">        t3.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Window implements Runnable&#123;</span><br><span class="line">    <span class="built_in">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sale<span class="constructor">Ticket()</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="built_in">int</span> sale<span class="constructor">Ticket()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;：售票，票号为 ：&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">            return <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">窗口1：售票，票号为 ：10</span><br><span class="line">窗口1：售票，票号为 ：9</span><br><span class="line">窗口1：售票，票号为 ：8</span><br><span class="line">窗口1：售票，票号为 ：7</span><br><span class="line">窗口1：售票，票号为 ：6</span><br><span class="line">窗口1：售票，票号为 ：5</span><br><span class="line">窗口1：售票，票号为 ：4</span><br><span class="line">窗口1：售票，票号为 ：3</span><br><span class="line">窗口1：售票，票号为 ：2</span><br><span class="line">窗口1：售票，票号为 ：1</span><br></pre></td></tr></table></figure>

<p>咱们上面说到，synchronized修饰方法时，使用到的同步监视器的当前对象(this)，所以说在上面的例子中，咱们要保证三个线程传入的对象是一致的，若不一致的话其实也就是各干各的了，不符合售票要求。</p>
<h2 id="保证线程安全方式三：Lock-锁机制"><a href="#保证线程安全方式三：Lock-锁机制" class="headerlink" title="保证线程安全方式三：Lock 锁机制"></a>保证线程安全方式三：Lock 锁机制</h2><p>从JDK 5开始，Java提供了更强大的线程同步机制————通过显示定义同步锁对象来实现同步。同步锁使用Lock对象来充当。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>先来介绍下Lock接口：<br>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。该接口提供有这两个方法：<br>(1) void lock()     获取锁<br>(2) void unlock()       释放锁</p>
<p>Lock 锁机制保证线程安全过程中，大体上分为三大步：<br>(1)实例化ReentrantLock；<br>(2)调用锁定方法（获取锁）：lock()；<br>(3)调用解锁方法（释放锁）：unlock()；</p>
<p>那ReentrantLock是个啥玩意呢：<br>ReentrantLock 是Lock接口的一个实现类，它拥有与synchronized相同的并发性和内存语义；在实现线程安全的控制中，常用的实现类就是 ReentrantLock。<br>它可以显示加锁，释放锁；通过lock()和unlock()配合使用，是一种手动锁，比较灵活；但是注意在使用这个锁时一定要注意释放锁，否则可能会造成死锁。</p>
<p>下面我们通过代码来了解Lock锁机制：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LockTest &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">Window</span> <span class="keyword">window</span> = <span class="built_in">new</span> <span class="keyword">Window</span>();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="built_in">new</span> Thread(<span class="keyword">window</span>);</span><br><span class="line">        Thread t2 = <span class="built_in">new</span> Thread(<span class="keyword">window</span>);</span><br><span class="line">        Thread t3 = <span class="built_in">new</span> Thread(<span class="keyword">window</span>);</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;窗口1&quot;);</span><br><span class="line">        t2.setName(&quot;窗口2&quot;);</span><br><span class="line">        t3.setName(&quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        t1.<span class="keyword">start</span>();</span><br><span class="line">        t2.<span class="keyword">start</span>();</span><br><span class="line">        t3.<span class="keyword">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Window</span> implements Runnable&#123;</span><br><span class="line">    private <span class="type">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    // <span class="number">1.</span>实例化ReentrantLock</span><br><span class="line">    private final ReentrantLock <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            // <span class="number">2.</span>调用锁定方法：<span class="keyword">lock</span>()</span><br><span class="line">            // <span class="keyword">lock</span>()必须紧跟代码块，避免中间代码抛出异常导致不能解锁等情况</span><br><span class="line">            <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket);</span><br><span class="line">                    ticket<span class="comment">--;</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">                // <span class="number">3.</span>调用解锁方法：unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">窗口1：售票，票号为：10</span><br><span class="line">窗口1：售票，票号为：9</span><br><span class="line">窗口1：售票，票号为：8</span><br><span class="line">窗口1：售票，票号为：7</span><br><span class="line">窗口1：售票，票号为：6</span><br><span class="line">窗口1：售票，票号为：5</span><br><span class="line">窗口1：售票，票号为：4</span><br><span class="line">窗口1：售票，票号为：3</span><br><span class="line">窗口1：售票，票号为：2</span><br><span class="line">窗口1：售票，票号为：1</span><br></pre></td></tr></table></figure>

<h2 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h2><p>1、synchronized与Lock都可以解决线程安全问题；<br>2、Lock是显示锁（手动开启和关闭锁，不要忘记关闭锁），synchronized是隐式锁，出了作用域自动释放。<br>3、Lock只有代码块锁，synchronized有代码块锁和方法锁。<br>4、使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（因为提供了更多的子类）。</p>
<p><strong>实际开发过程中优先使用顺序：</strong><br>Lock锁——&gt;同步代码块（已经进入了方法体，分配了相应资源）——&gt;同步方法（在方法体之外）</p>
<h2 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h2><p><strong>死锁：</strong>不同的线程分别占用对方的需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。<br>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续处理其他事情。</p>
<p><strong>解决/避免方法：</strong><br>1、专门的算法、原则；<br>2、尽量减少同步资源的定义；<br>3、尽量避免嵌套同步。</p>
<h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><p>饿汉式原本就是线程安全的；懒汉式需要使用同步代码块的方式去保证线程安全。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTest &#123;</span><br><span class="line">	// 方法一：饿汉式</span><br><span class="line">    /*private<span class="keyword"> static</span> Person person =<span class="built_in"> new </span>Person();</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Person getPersion()&#123;</span><br><span class="line">       <span class="built_in"> return </span>person;</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    // 方法二：懒汉式</span><br><span class="line">    /**</span><br><span class="line">     * 实例声明成 volatile，避免指令重排造成导致实例未初始化的问题</span><br><span class="line">     * 双重null判断避免了实例已经初始化，但是线程每次还要等待锁产生的性能问题</span><br><span class="line">     */</span><br><span class="line">   <span class="keyword"> private</span> volatile<span class="keyword"> static</span> Person instance;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Person getSingleton() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            synchronized (Person.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Person();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方式三</span><br><span class="line">    /**</span><br><span class="line">     * 通过静态内部类的方式获取，这种方法也是《Effective Java》上所推荐的。</span><br><span class="line">     * 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，</span><br><span class="line">     * 除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；</span><br><span class="line">     * 同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</span><br><span class="line">     */</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> class SingletonHolder &#123;</span><br><span class="line">       <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> Person INSTANCE =<span class="built_in"> new </span>Person();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Person getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，保证线程安全有同步代码块、同步方法和Lock锁这几种方法，实际开发中推荐使用Lock锁的，因为使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性。本篇就完结啦。</p>
</div><div class="tags"><a href="/tags/Java%E8%BF%9B%E9%98%B6/"><i class="fa fa-tag"></i>Java进阶</a></div><div class="post-nav"><a class="pre" href="/2020/08/10/java_IO%E6%B5%81/">Java-IO流</a><a class="next" href="/2020/07/26/java_%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java-多线程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis%E9%AB%98%E7%BA%A7/" style="font-size: 15px;">Redis高级</a> <a href="/tags/Redis%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Redis基础</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/" style="font-size: 15px;">等级保护</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/docker/">Docker的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis分布式锁(高级篇系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80(%E7%B3%BB%E5%88%97%E4%BA%94)/">JVM之对象的内存布局(系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA(%E7%B3%BB%E5%88%97%E5%9B%9B)/">JVM之方法区(系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM%E4%B9%8B%E5%A0%86(%E7%B3%BB%E5%88%97%E4%B8%89)/">JVM之堆(系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B(%E7%B3%BB%E5%88%97%E4%BA%8C)/">JVM之运行时数据区(系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F(%E7%B3%BB%E5%88%97%E4%B8%80)/">JVM之类加载子系统(系列一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/13/Python%E5%9C%A8Linux%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/">Python实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>