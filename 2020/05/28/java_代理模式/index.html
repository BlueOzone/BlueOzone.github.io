<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>细说Java的代理模式 | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">细说Java的代理模式</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">细说Java的代理模式</h1><div class="post-meta">2020-05-28<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Java代理的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">基于JDK的动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">基于CGLIB的动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EJDK%E5%92%8C%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">基于JDK和基于CGLIB的动态代理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">动态代理总结</span></a></li></ol></div></div><div class="post-content"><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。<span id="more"></span><br>这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。<br>这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需要修改，可以通过代理的方式来扩展该方法。</p>
<h2 id="Java代理的分类"><a href="#Java代理的分类" class="headerlink" title="Java代理的分类"></a>Java代理的分类</h2><p>大体上可以分为动态代理和静态代理两类，但在实现上又可以分为三种：<br>(1)静态代理<br>(2)基于JDK的动态代理<br>(3)基于CGLIB的动态代理<br>下面我们来说说这三种代理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理需要代理对象和被代理对象实现一样的接口。<br>特点：代理类和被代理类在编译期间，就确定下来了；<br>缺点：较为冗余，若需要给几个类实现代理，则需要写好几个的代理类，不易于维护和理解。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">interface ClothFactory&#123;</span><br><span class="line">    void produceCloth();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代理类</span><br><span class="line">class ProxyClothFactory implements ClothFactory&#123;</span><br><span class="line">    private ClothFactory factory;</span><br><span class="line"></span><br><span class="line">    public ProxyClothFactory(ClothFactory factory)&#123;</span><br><span class="line">        this.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void produceCloth() &#123;</span><br><span class="line">        System.out.println(&quot;代理类做一些准备工作&quot;);</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">        System.out.println(&quot;代理类做一些收尾工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被代理类</span><br><span class="line">class NikeClothFactory implements ClothFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produceCloth() &#123;</span><br><span class="line">        System.out.println(&quot;Nike工厂生产一批衣服&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StaticProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NikeClothFactory nikeClothFactory = new NikeClothFactory();</span><br><span class="line">        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nikeClothFactory);</span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代理类做一些准备工作</span><br><span class="line">Nike工厂生产一批衣服</span><br><span class="line">代理类做一些收尾工作</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是指程序运行时根据需要，动态的在内存中创建目标类的代理对象，从而实现对目标对象的代理功能。<br><strong>动态代理相比于静态代理的优点：</strong><br>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。<br>实现动态代理通常有这两种方式：基于JDK的动态代理、基于CGLIB的动态代理。</p>
<h3 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a>基于JDK的动态代理</h3><p>JDK的动态代理利用了JDK API，只能为接口创建代理，主要涉及到了java.lang.reflect包中的两个类：Proxy和InvocationHandler。<br>其中 InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，在并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。<br>而Proxy则为InvocationHandler实现类动态创建一个符合某一接口的代理实例。</p>
<p>实现代理时，Proxy类会使用到newProxyInstance方法,但是该方法需要接收三个参数，完整的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</span><br></pre></td></tr></table></figure>

<p>注意该方法是在Proxy类中是静态方法，且接收的三个参数依次为：</p>
<p><code>ClassLoader loader</code> ：指定当前目标对象使用类加载器,获取加载器的方法是固定的；<br><code>Class&lt;?&gt;[] interfaces</code> ：目标对象实现的接口的类型,使用泛型方式确认类型；<br><code>InvocationHandler h</code> ：事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入。</p>
<p>实现代理时，需要用到InvocationHandler接口，该接口定义了一个 invoke(Object proxy, Method method, Object[] args)的方法，其中的参数释义为：<br><code>proxy</code> ：是代理实例，一般不会用到；<br><code>method</code> ：是代理实例上的方法，通过它可以发起对目标类的反射调用；<br><code>args</code> ：是通过代理类传入的方法参数，在反射调用时使用。</p>
<p>基于JDK的动态代理的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">interface Human&#123;</span><br><span class="line">    String getBelief();</span><br><span class="line">    void eat(String food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被代理类</span><br><span class="line">class SuperMan implements Human&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getBelief() &#123;</span><br><span class="line">        return &quot;I believe I can fly&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat(String food) &#123;</span><br><span class="line">        System.out.println(&quot;我喜欢吃&quot; + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyFactory&#123;</span><br><span class="line">    //调用此方法，返回一个代理类的对象，解决问题一</span><br><span class="line">    public static Object getProxyInstance(Object obj)&#123;</span><br><span class="line">        //obj:被代理类的对象</span><br><span class="line">        MyInvocationHandler handler = new MyInvocationHandler();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvocationHandler implements InvocationHandler&#123;</span><br><span class="line">    </span><br><span class="line">    private Object obj;//需要使用被代理类的对象进行赋值</span><br><span class="line"></span><br><span class="line">    public void bind(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当我们通过代理类的对象，调用方法a时，同时会自动的调用如下的方法：invoke()</span><br><span class="line">    //将被代理类要执行的方法a的功能，声明在invoke()中</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;开始...&quot;);</span><br><span class="line">        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span><br><span class="line">        //obj:被代理类的对象</span><br><span class="line">        //通过反射机制调用目标对象的方法</span><br><span class="line">        Object returnValue = method.invoke(obj, args);</span><br><span class="line">        System.out.println(&quot;结束...&quot;);</span><br><span class="line">        //此返回值就是被代理类对象调用相应方法的返回值</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperMan superMan = new SuperMan();</span><br><span class="line">        //注意，这里的Human不能写成SuperMan；因为动态代理会根据你实现的接口去生成对应的代理对象，不保证一定是SuperMan类型的</span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(&quot;apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始...</span><br><span class="line">结束...</span><br><span class="line">I believe I can fly</span><br><span class="line">开始...</span><br><span class="line">我喜欢吃apple</span><br><span class="line">结束...</span><br></pre></td></tr></table></figure>

<h3 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a>基于CGLIB的动态代理</h3><p>使用JDK创建代理有一个限制，即JDK动态代理只能为接口创建代理，这一点我们从Proxy的接口方法<code>newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code>就看得很清楚，第二个入参interfaces就是为代理实例指定的实现接口。</p>
<p>现在的问题是：对于没有通过接口定义业务方法的类，如何动态创建代理实例呢？JDK的代理技术显然已经黔驴技穷，CGLib作为一个替代者，填补了这个空缺。<br>CGLib实现动态代理时，需要实现MethodInterceptor接口，需要重写intercept方法，这里先来解释一下该方法的参数含义：</p>
<p><code>@param1 obj</code> ：代理对象本身<br><code>@param2 method</code> ： 被拦截的方法对象<br><code>@param3 args</code>：方法调用入参<br><code>@param4 proxy</code>：用于调用被拦截方法的方法代理对象</p>
<p>基于CGLIB的动态代理的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//被代理类</span><br><span class="line">class SuperMan&#123;</span><br><span class="line">    public void getBelief() &#123;</span><br><span class="line">        System.out.println(&quot;I believe I can fly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;我喜欢吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyFactory implements MethodInterceptor &#123;</span><br><span class="line">    private Object obj;//需要使用被代理类的对象进行赋值</span><br><span class="line"></span><br><span class="line">    public ProxyFactory(Object obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //给目标对象创建一个代理对象</span><br><span class="line">    public Object getProxyInstance()&#123;</span><br><span class="line">        //Enhancer可以用来为无接口的类创建代理；它会根据某个给定的类创建子类，并且所有非final的方法都带有回调钩子。</span><br><span class="line">        //1.工具类</span><br><span class="line">        Enhancer en = new Enhancer();</span><br><span class="line">        //2.设置父类</span><br><span class="line">        en.setSuperclass(obj.getClass());</span><br><span class="line">        //3.设置回调对象为本身</span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        //4.通过字节码技术动态创建子类实例</span><br><span class="line">        return en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;开始...&quot;);</span><br><span class="line">        //写法一：</span><br><span class="line">        /*</span><br><span class="line">        通过反射机制调用目标对象的方法</span><br><span class="line">        Object invoke = method.invoke(obj, objects);</span><br><span class="line">        */</span><br><span class="line">        //写法二：（正确）</span><br><span class="line">        /*</span><br><span class="line">        通过FastClass的机制来实现对被拦截方法的调用</span><br><span class="line">         */</span><br><span class="line">        Object returnValue = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(&quot;结束...&quot;);</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CGLIBProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProxyFactory proxyFactory = new ProxyFactory(new SuperMan());</span><br><span class="line">        SuperMan proxyInstance = (SuperMan) proxyFactory.getProxyInstance();</span><br><span class="line"></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">        proxyInstance.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始...</span><br><span class="line">I believe I can fly</span><br><span class="line">结束...</span><br><span class="line">开始...</span><br><span class="line">我喜欢吃</span><br><span class="line">结束...</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>intercept方法因为具有MethodProxy proxy参数的原因，不再需要代理类的引用对象了，直接通过proxy对象访问被代理对象的方法(这种方式更快)。<br>当然也可以通过反射机制，通过method引用实例：<br><code>Object result = method.invoke(target, args)</code> 的形式反射调用被代理类方法。</p>
<p>JDK动态代理的拦截对象是通过反射的机制来调用被拦截方法的，反射的效率比较低，所以CGLIB采用了FastClass的机制来实现对被拦截方法的调用。FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法。</p>
<p>FastClass使用：动态生成一个继承FastClass的类，并向类中写入委托对象，直接调用委托对象的方法。<br>FastClass逻辑：在继承FastClass的动态类中，根据方法签名(方法名字+方法参数)得到方法索引，根据方法索引调用目标对象方法。<br>FastClass优点：FastClass用于代替Java反射，避免了反射造成调用慢的问题。</p>
<h2 id="基于JDK和基于CGLIB的动态代理的区别"><a href="#基于JDK和基于CGLIB的动态代理的区别" class="headerlink" title="基于JDK和基于CGLIB的动态代理的区别"></a>基于JDK和基于CGLIB的动态代理的区别</h2><p><strong>JDK的动态代理必须具备四个条件：</strong></p>
<ul>
<li>目标接口</li>
<li>目标类</li>
<li>拦截器（处理器）</li>
<li>代理类</li>
</ul>
<p>1、因为利用JDKProxy生成的代理类实现了接口，所以目标类中所有的方法在代理类中都有。<br>2、生成的代理类的所有的方法都拦截了目标类的所有的方法。而拦截器（处理器）中invoke方法的内容正好就是代理类的各个方法的组成体。<br>3、利用JDKProxy方式必须有接口的存在。<br>4、invoke方法中的三个参数可以访问目标类的被调用方法的API、被调用方法的参数、被调用方法的返回类型。</p>
<p><strong>基于CGLIB的动态代理：</strong><br>1、CGlib是一个强大的，高性能，高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。<br>2、用CGlib生成代理类是目标类的子类。<br>3、用CGlib生成代理类不需要接口。<br>4、用CGLib生成的代理类重写了父类的各个方法。<br>5、拦截器中的intercept方法内容正好就是代理类中的方法体。</p>
<h2 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h2><p>JDK动态代理所创建的代理对象，在JDK 1.3下，性能强差人意。虽然在高版本的JDK中，动态代理对象的性能得到了很大的提高，但是有研究表明：<br>CGLib所创建的动态代理对象的性能依旧比JDK的所创建的代理对象的性能高不少（大概10倍）。<br>而CGLib在创建代理对象时性能却比JDK动态代理慢很多（大概8倍）。</p>
<p>所以对于singleton的代理对象或者具有实例池的代理，因为不需要频繁创建代理对象，所以比较适合用CGLib动态代理技术，反之适合用JDK动态代理技术。此外，由于CGLib采用生成子类的技术创建代理对象，所以不能对目标类中的final方法进行代理。</p>
</div><div class="tags"><a href="/tags/Java%E8%BF%9B%E9%98%B6/"><i class="fa fa-tag"></i>Java进阶</a></div><div class="post-nav"><a class="pre" href="/2020/07/11/java_%E5%8F%8D%E5%B0%84/">Java-反射</a><a class="next" href="/2020/05/20/java_Map/">Java-Map之HashMap</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis%E9%AB%98%E7%BA%A7/" style="font-size: 15px;">Redis高级</a> <a href="/tags/Redis%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Redis基础</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/" style="font-size: 15px;">等级保护</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/docker/">Docker的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis分布式锁(高级篇系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80(%E7%B3%BB%E5%88%97%E4%BA%94)/">JVM之对象的内存布局(系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA(%E7%B3%BB%E5%88%97%E5%9B%9B)/">JVM之方法区(系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM%E4%B9%8B%E5%A0%86(%E7%B3%BB%E5%88%97%E4%B8%89)/">JVM之堆(系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B(%E7%B3%BB%E5%88%97%E4%BA%8C)/">JVM之运行时数据区(系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F(%E7%B3%BB%E5%88%97%E4%B8%80)/">JVM之类加载子系统(系列一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/13/Python%E5%9C%A8Linux%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/">Python实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>