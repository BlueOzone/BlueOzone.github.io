<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Redis为什么那么快(高级篇系列一) | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis为什么那么快(高级篇系列一)</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis为什么那么快(高级篇系列一)</h1><div class="post-meta">2020-10-15<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">Redis的五大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">基于内存实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">高效的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B0%E5%AF%8C%E5%90%88%E7%90%86%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">丰富合理的编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zset%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">Zset类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E3%80%81%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">非阻塞IO、多路IO复用模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-6-0%E5%90%8E%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%90%E9%80%9F"><span class="toc-number">3.</span> <span class="toc-text">Redis 6.0后引入多线程提速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">Redis 过期策略和内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">4.1.</span> <span class="toc-text">Redis的过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-number">4.1.1.</span> <span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">4.1.2.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">4.1.3.</span> <span class="toc-text">定期删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E7%A7%8D%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">6种内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9Redis%E8%BF%90%E8%A1%8C%E5%BE%97%E9%82%A3%E4%B9%88%E5%9C%B0%E5%BF%AB%E9%80%9F"><span class="toc-number">5.</span> <span class="toc-text">如何让Redis运行得那么地快速</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%9A%84key"><span class="toc-number">5.1.</span> <span class="toc-text">尽量使用短的key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8keys%E5%92%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">避免使用keys和模糊查询操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEkey%E6%9C%89%E6%95%88%E6%9C%9F"><span class="toc-number">5.3.</span> <span class="toc-text">设置key有效期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8"><span class="toc-number">5.4.</span> <span class="toc-text">尽可能地使用哈希存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%80%E5%A5%BD%E5%9C%A8%E5%A4%87%E5%BA%93%E5%81%9A"><span class="toc-number">5.5.</span> <span class="toc-text">持久化最好在备库做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93"><span class="toc-number">5.6.</span> <span class="toc-text">多条命令使用管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6Redis%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.7.</span> <span class="toc-text">限制Redis的内存大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8SSD"><span class="toc-number">5.8.</span> <span class="toc-text">尽可能使用SSD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFslowlog"><span class="toc-number">5.9.</span> <span class="toc-text">开启slowlog</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis到底有多快？官方提供的数据中，Redis可以达到100000+的QPS（每秒内查询次数）；十万多的QPS，已经非常厉害了，为啥它的速度这么快呢？总的来说是因为Redis 有<strong>五大特性以及Redis 优秀的过期策略和内存淘汰策略</strong>，下面我们来一起看一下。<span id="more"></span></p>
<h2 id="Redis的五大特性"><a href="#Redis的五大特性" class="headerlink" title="Redis的五大特性"></a>Redis的五大特性</h2><h3 id="基于内存实现"><a href="#基于内存实现" class="headerlink" title="基于内存实现"></a>基于内存实现</h3><p>Redis完全基于内存，大部分都是简单的存取操作，大量的时间花费在IO上。Redis绝大部分操作时间复杂度为 O(1) ，所以速度十分快。</p>
<h3 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h3><p>Redis底层支持五种不同的数据机构，多种数据结构可以在不同场景下，支持不同的数据类型。</p>
<h3 id="丰富合理的编码"><a href="#丰富合理的编码" class="headerlink" title="丰富合理的编码"></a>丰富合理的编码</h3><p>Redis底层提供了丰富而合理的编码。根据长度及元素的个数的不同，五种数据结构也适配了不同的编码格式。<br>每种数据类型都提供了<strong>最少两种</strong>内部的编码格式（在Redis版本小于3.2的时候），而且每个数据类型内部编码方式的选择<strong>对用户是完全透明的</strong>，Redis会根据数据量自适应地选择较优化的内部编码格式。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>字符串是 Redis最基本的数据结构，Redis并没有使用C语言的字符串，而是使用了简单动态字符串(SDS)。Redis 中字符串对象的编码有三种：<code>int</code>，<code>raw</code> 或者 <code>embstr</code>。</p>
<ul>
<li><p><strong>int 编码</strong>：保存long 型的64位有符号整数</p>
</li>
<li><p><strong>embstr 编码</strong>：保存长度小于44字节的字符串</p>
</li>
<li><p><strong>raw 编码</strong>：保存长度大于44字节的字符串</p>
</li>
</ul>
<p>大家可以测试一下，通过<code>Ohject encoding keyname</code>命令去查看字符串所使用的编码类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set testKey 111</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding testKey</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set testKey testValue</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding testKey</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; set testKey tesssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding testKey</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>网上查阅了Redis List数据结构使用的内部编码的相关资料，发现绝大部分说的都是<code>ziplist</code> + <code>linkedlist</code>，于是乎我拿着我的Redis测试了一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listKey teeeeeeeeeeeeeee dsad asda dwqwe qeq</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding listKey</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure>

<p>这个<code>quicklist</code>又是个啥玩意，于是乎发现问题没那么简单。</p>
<p><strong>Redis &lt; 3.2</strong> 版本的时候，当元素个数较少且没有大元素时，内部编码为<code>ziplist</code>；当元素个数超过512个或者某个元素超过64个字节时，内部编码为 <code>linkedlist</code> 编码。</p>
<p><strong>Redis &gt;= 3.2 <strong>后，Redis 重新引入了一个 <code>quicklist</code> 的数据结构，列表的底层</strong>都由<code>quicklist</code>实现</strong>。</p>
<p><code>quicklist</code> 实际上是 <code>zipList</code> 和 <code>linkedList</code> 的混合体，它将 <code>linkedList</code> 按段切分，每一段使用 <code>zipList</code> 来紧凑存储，多个 <code>zipList</code> 之间使用双向指针串接起来。</p>
<p>所以说，Redis 在 3.2 版本之后，List数据结构使用的内部编码为 <code>quicklist</code>；所以啪啪打脸了前面说的Redis每种数据类型都提供了<strong>最少两种</strong>内部的编码格式。</p>
<h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>Hash也是 Redis 使用非常频繁的数据结构，Redis 中hash结构的编码有两种：<code>ziplist</code>和 <code>hashtable</code>。</p>
<ul>
<li><strong>ziplist 编码</strong>：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64个字节）时，Redis会使用<code>ziplist</code>作为哈希的内部实现。<br><code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比<code>hashtable</code>更加优秀。</li>
<li><strong>hashtable 编码</strong>：当哈希类型无法满足<code>ziplist</code>的条件时，Redis会使用<code>hashtable</code>作为哈希的内部实现。因为此时<code>ziplist</code>的读写效率会下降，而<code>hashtable</code>的读写时间复杂度为O(1)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6400&gt; hset hKey fieldName testValue</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6400&gt; Object encoding hKey</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; hset hKey fieldName testValuerrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrppppppppppppppppppppppppppppppp</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; Object encoding hKey</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h4><p>Redis 中 Set 结构的编码也有两种：<code>intset</code> 和 <code>hashtable</code>。</p>
<ul>
<li><p><strong>intset（整数集合）编码</strong>：当集合中的元素<strong>都是整数且元素个数小于set-max-intset-entries配置（默认512个）</strong>时，Redis会选用<code>intset</code>来作为集合内部实现，从而减少内存的使用。</p>
</li>
<li><p><strong>hashtable（哈希表）编码</strong>：当集合类型无法满足<code>intset</code>的条件时（比如当元素个数超过512个或某个元素不为整数时），Redis会使用<code>hashtable</code>作为集合的内部实现。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6400&gt; sadd setKey 2 3 4 5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; Object encoding setKey</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; sadd setKey 2 3 4 5 sdasafaf</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6400&gt; Object encoding setKey</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h4><p>Redis 中 Zset 结构的编码也有两种：<code>ziplist</code> 和 <code>skiplist</code>。</p>
<ul>
<li><p><strong>ziplist（压缩列表）编码</strong>：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个）同时每个元素的值小于zset-max-ziplist-value配置（默认64个字节）时，Redis会用<code>ziplist</code>来作为有序集合的内部实现，<code>ziplist</code>可以有效减少内存使用。</p>
</li>
<li><p><strong>skiplist（跳跃表）编码</strong>：当<code>ziplist</code>条件不满足时，有序集合会使用<code>skiplist</code>作为内部实现，因为此时<code>ziplist</code>的读写效率会下降。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6400&gt; zadd zsetKey 50 a 60 b 30 c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; Object encoding zsetKey</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br><span class="line">127.0.0.1:6400&gt; zadd zsetKey 50 a 60 b 30 ceeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6400&gt; Object encoding zsetKey</span><br><span class="line">&quot;skiplist&quot;</span><br><span class="line">127.0.0.1:6400&gt;</span><br></pre></td></tr></table></figure>

<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p><strong>Redis的单线程是指处理网络请求只有一个线程。</strong>那么Redis的核心网络模型为什么选择用单线程来实现呢？</p>
<p>Redis 官方回答的核心意思是：<strong>对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型</strong>；如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。</p>
<p>实际上更加具体的选择单线程的原因可以归结为以下三点：</p>
<p>（1）避免过多的上下文切换开销；</p>
<p>（2）避免同步机制的开销；</p>
<p>（3）简单可维护。</p>
<p>也因此，对于单线程来讲就不存在上下文切换问题，也不用考虑锁的问题，不存在加锁释放锁的操作，也就没有因为可能出现死锁而导致的性能消耗。</p>
<p>虽然单线程无法发挥出多个CPU的性能，但是可以在单机开启多个Redis实例解决这个问题；但实际上，为了保证高可用，线上业务一般不太可能会是单机模式，更加常见的是利用 Redis 分布式集群多节点和数据分片负载均衡来提升性能和保证高可用。</p>
<h3 id="非阻塞IO、多路IO复用模型"><a href="#非阻塞IO、多路IO复用模型" class="headerlink" title="非阻塞IO、多路IO复用模型"></a>非阻塞IO、多路IO复用模型</h3><p>Redis采用多路IO复用模型，在内部采用epoll代理。多路是指多个网络连接，IO复用是指复用同一个线程。epoll会同时监察多个流的IO事件，在空闲时，当前线程进入阻塞，如果有IO事件时，线程会被唤醒，并且epoll会通知线程是哪个流发生了IO事件，然后按照顺序处理，减少了网络IO的时间消耗，避免了大量的无用操作。</p>
<h2 id="Redis-6-0后引入多线程提速"><a href="#Redis-6-0后引入多线程提速" class="headerlink" title="Redis 6.0后引入多线程提速"></a>Redis 6.0后引入多线程提速</h2><p>前面提到 Redis 最初选择单线程网络模型的理由是：CPU 通常不会成为性能瓶颈，瓶颈往往是<strong>内存</strong>和<strong>网络</strong>，因此单线程足够了。那么为什么现在 Redis 又要引入多线程呢？很简单，就是 Redis 的网络 I/O 瓶颈已经越来越明显了。</p>
<p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis 的性能有两个方向：</p>
<ul>
<li>优化网络 I/O 模块</li>
<li>提高机器内存读写的速度</li>
</ul>
<p>后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：</p>
<ul>
<li>零拷贝技术或者 DPDK 技术</li>
<li>利用多核优势</li>
</ul>
<p>零拷贝技术有其局限性，无法完全适配 Redis 这一类复杂的网络 I/O 场景；而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。</p>
<p>因此，利用多核优势成为了优化网络 I/O 性价比最高的方案。</p>
<p>所以Redis支持多线程主要就是两个原因：<br>（1）可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；<br>（2）多线程任务可以分摊 Redis 同步 IO 读写负荷。</p>
<p><strong>关于多线程须知：</strong><br>Redis 6.0 版本 默认多线程是关闭的<code> io-threads-do-reads no</code>；<br>Redis 6.0 版本 开启多线程后线程数也要谨慎设置。<br>多线程可以使得性能翻倍，但是多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>
<h2 id="Redis-过期策略和内存淘汰策略"><a href="#Redis-过期策略和内存淘汰策略" class="headerlink" title="Redis 过期策略和内存淘汰策略"></a>Redis 过期策略和内存淘汰策略</h2><h3 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h3><p>Redis中key的过期策略通常有以下三种：</p>
<h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>Redis对每个设置过期时间的key都创建了一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>expires字典会保存所有设置了过期时间的key的过期时间数据，其中 key 是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。</p>
<p>Redis默认采用的过期策略：<strong>惰性删除 + 定期删除</strong>，在不同情况下使得CPU和内存资源达到最优的平衡效果。memcached采用的过期策略：<strong>惰性删除</strong>。</p>
<h3 id="6种内存淘汰策略"><a href="#6种内存淘汰策略" class="headerlink" title="6种内存淘汰策略"></a>6种内存淘汰策略</h3><p>Redis的内存淘汰策略是指在Redis的可用内存不足时，Redis自身有什么策略去应对这种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volatile-lru：内存不足时，从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 </span><br><span class="line">volatile-ttl：内存不足时，从已设置过期时间的数据集中挑选将要过期的数据淘汰 </span><br><span class="line">volatile-random：内存不足时，从已设置过期时间的数据集中任意选择数据淘汰 </span><br><span class="line">allkeys-lru：内存不足时，从数据集中挑选最近最少使用的数据淘汰 </span><br><span class="line">allkeys-random：内存不足时，从数据集中任意选择数据淘汰 </span><br><span class="line">no-enviction（驱逐）：禁止驱逐数据，不删除的意思；当内存不足以容纳新写入数据时，新写入操作会报错。</span><br></pre></td></tr></table></figure>
<p>Redis 5.0.3版本中，默认值是noeviction。不同版本会有不同的默认值，具体可以看配置文件中如何说明的。</p>
<p><strong>总结：</strong>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据，过期策略用于处理过期的缓存数据。</p>
<h2 id="如何让Redis运行得那么地快速"><a href="#如何让Redis运行得那么地快速" class="headerlink" title="如何让Redis运行得那么地快速"></a>如何让Redis运行得那么地快速</h2><p>前面我们已经了解到Redis为什么这么快，但是我们也要正确的使用Redis，才能将它的速度真正发挥好来，下面我们来了解一下日常使用中，Redis的注意点或者说优化点：</p>
<h3 id="尽量使用短的key"><a href="#尽量使用短的key" class="headerlink" title="尽量使用短的key"></a>尽量使用短的key</h3><p>由于Redis单线程的特性，操作数据过长的key的通常比较耗时，也就意味着阻塞Redis可能性越大，这样会造成客户端阻塞或者引起故障切换。还可能会产生内存空间不均匀、网络拥塞的问题，所以日常开发中key在表达其意义的基础上，尽量的短。</p>
<h3 id="避免使用keys和模糊查询操作"><a href="#避免使用keys和模糊查询操作" class="headerlink" title="避免使用keys和模糊查询操作"></a>避免使用keys和模糊查询操作</h3><p><code>keys *</code>返回所有的key，该命令会引起Redis进入阻塞！慎用。</p>
<p>模糊查询也会导致阻塞，如果有需求可以使用SCAN命令代替。</p>
<h3 id="设置key有效期"><a href="#设置key有效期" class="headerlink" title="设置key有效期"></a>设置key有效期</h3><p>给key设置有效期可以避免很多问题，如：Redis作为缓存时的双写问题，保证缓存和数据库的一致性。另外设置缓存过去时间时不要设置为一样，否则会同时把压力压到数据库。</p>
<h3 id="尽可能地使用哈希存储"><a href="#尽可能地使用哈希存储" class="headerlink" title="尽可能地使用哈希存储"></a>尽可能地使用哈希存储</h3><h3 id="持久化最好在备库做"><a href="#持久化最好在备库做" class="headerlink" title="持久化最好在备库做"></a>持久化最好在备库做</h3><p>可以减少主库写的压力。</p>
<h3 id="多条命令使用管道"><a href="#多条命令使用管道" class="headerlink" title="多条命令使用管道"></a>多条命令使用管道</h3><p>使用管道可以降低网络的开销。</p>
<h3 id="限制Redis的内存大小"><a href="#限制Redis的内存大小" class="headerlink" title="限制Redis的内存大小"></a>限制Redis的内存大小</h3><p>Redis在bgsvae的时候，会fork子进程，而这个操作需要拷贝父进程的空间内存页表，会耗费一定的时间。所以每个Redis实例的内存最好控制在10G以内，避免因为fork太久而导致的性能问题。</p>
<h3 id="尽可能使用SSD"><a href="#尽可能使用SSD" class="headerlink" title="尽可能使用SSD"></a>尽可能使用SSD</h3><p>Redis在持久化的时候首先会写入aof buffer，再进行fsync。这时，主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。所以应使用SSD，来提高磁盘读写速度。</p>
<h3 id="开启slowlog"><a href="#开启slowlog" class="headerlink" title="开启slowlog"></a>开启slowlog</h3><p>开启slowlog可以帮助我们定位数据库性能问题。</p>
</div><div class="tags"><a href="/tags/Redis%E9%AB%98%E7%BA%A7/"><i class="fa fa-tag"></i>Redis高级</a></div><div class="post-nav"><a class="pre" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a><a class="next" href="/2020/09/20/Redis%E9%9B%86%E7%BE%A4(%E5%9F%BA%E7%A1%80%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%94)/">Redis集群(基础篇系列五)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis%E9%AB%98%E7%BA%A7/" style="font-size: 15px;">Redis高级</a> <a href="/tags/Redis%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Redis基础</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/" style="font-size: 15px;">等级保护</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/docker/">Docker的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis分布式锁(高级篇系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80(%E7%B3%BB%E5%88%97%E4%BA%94)/">JVM之对象的内存布局(系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA(%E7%B3%BB%E5%88%97%E5%9B%9B)/">JVM之方法区(系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM%E4%B9%8B%E5%A0%86(%E7%B3%BB%E5%88%97%E4%B8%89)/">JVM之堆(系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B(%E7%B3%BB%E5%88%97%E4%BA%8C)/">JVM之运行时数据区(系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F(%E7%B3%BB%E5%88%97%E4%B8%80)/">JVM之类加载子系统(系列一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/13/Python%E5%9C%A8Linux%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/">Python实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>