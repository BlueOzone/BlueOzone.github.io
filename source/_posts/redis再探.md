---
title: Redis再探
date: 2020-10-15 19:34:14
categories: Redis
tags: Redis技术
toc: true
---

### Redis基本命令
注意，Redis的命令是不区分大小写的。
<!--more-->

`select`：切换数据库。
`dbsize`：查看当前数据库的key的数量。
`flushdb`：清空当前库。
`flushall`：清空全部库。
`randomkey`：随机返回一个键。
`scan num`：渐进扫描key，不会造成redis阻塞，scan命令会返回一个游标值，需要在下次扫描时以这个游标值作为参数。

### Redis主从集群

**主从复制：**
Redis 主从复制可将主节点数据同步给从节点，从节点此时有两个作用：
1、一旦主节点宕机，从节点作为主节点的备份可以随时顶上来。
2、扩展主节点的读能力，分担主节点读压力。


**主从集群：**
从redis 3.0版本开始支持redis-cluster集群，redis-cluster采用无中心结构，每一个节点都保存有这个集群所有主节点以及从节点的信息，及集群状态，每个节点都和其他节点连接。所以redis-cluster是一种服务端分片技术。


#### Redis集群的功能限制
Redis 集群相对单机在功能上存在一些**限制**，需要开发人员提前了解，在使用时做好规避。

- key 批量操作支持有限。

- 类似 `mset、mget` 操作，目前只支持对具有相同 slot 值的 key 执行 批量操作。对于映射为不同 slot 值的 key 由于执行 `mset、mget` 等操作可能存在于多个节点上，因此不被支持。

- key 事务操作支持有限。

- 只支持多 key 在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。

- key 作为数据分区的最小粒度。

- 不能将一个大的键值对象如 hash、list 等映射到不同的节点。

- 不支持多数据库空间。

- 单机下的Redis可以支持 16 个数据库（db0 ~ db15），集群模式下只能使用一个数据库空间，即 db0。

- 复制结构只支持一层。

- Redis集群部署至少需要3个及3个以上节点。

- 从节点只能复制主节点，不支持嵌套树状复制结构。


Redis集群创建命令：
去到redis目录执行：
`./src/redis-cli -a redis密码 --cluster create 每个redis的ip+port，使用空格分隔 --cluster-replicas 0`

`--cluster-replicas 0` 后面的数字代表为每个主节点分配对应个数的从节点；
如果你有6个节点，创建集群的时候填0，就会形成6个都是主节点的redis集群；
如果你有6个节点，创建集群的时候填1，就会形成3主3从的redis集群。


#### Redis主从复制的性能问题：
第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。
第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和Master断开重连都会重复以上过程。
Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从复制无阻塞，但由于磁盘io的限制，如果Master快照文件比较大，那么dump会耗费比较长的时间，这个过程中Master可能无法响应请求，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。


#### redis-cluster架构
每个节点都和n-1个节点通信，这被称为集群总线（cluster bus）。它们使用特殊的端口号，即对外服务端口号加10000。所以要维护好这个集群的每个节点信息，不然会导致整个集群不可用，其内部采用特殊的二进制协议优化传输速度和带宽。
redis-cluster把所有的物理节点映射到[0,16383]slot（槽）上，cluster负责维护node--slot--value。
集群预先给所有节点分好16384个桶，每个节点得到部分桶，当需要在redis集群中插入数据时，根据CRC16(KEY) mod 16384的值，决定将一个key放到哪个桶中。
客户端与redis节点直连，不需要连接集群所有的节点，连接集群中任何一个可用节点即可。整个cluster被看做是一个整体，客户端可连接任意一个节点进行操作，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点。
redis-trib.rb脚本（rub语言）为集群的管理工具，比如自动添加节点，规划槽位，迁移数据等一系列操作。
节点的fail是通过集群中超过半数的节点检测失效时才生效。集群节点之间通过互相的ping-pong判断是否可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点。如果某个节点和所有从节点全部挂掉，集群就进入fail状态，也可以理解成集群的slot映射[0-16383]不完整时进入fail状态。如果有一半以上的主节点宕机，那么无论这些节点有没有从节点，集群同样进入fail状态。这就是redis的投票机制。
为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，redis cluster会根据选举算法从slave节点中选择一个上升为master节点，整个集群继续对外提供服务。

### Redis为什么那么快
Redis有多快？它采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。下面分析说明一下Redis那么快的原因：

#### 基于内存实现
数据都存储在内存里，相比磁盘IO操作快百倍，操作速率很快。

#### 高效的数据结构：
Redis底层多种数据结构支持不同的数据类型，比如HyperLogLog它连2个字节都不想浪费。

#### 丰富而合理的编码：
Redis底层提供了 丰富而合理的编码  ，五种数据类型根据长度及元素的个数适配不同的编码格式。
1、String：自动存储int类型，非int类型用raw编码。
2、List：字符串长度且元素个数小于一定范围使用 ziplist 编码，否则转化为 linkedlist 编码。
3、Hash：hash 对象保存的键值对内的键和值字符串长度小于一定值及键值对。
4、Set：保存元素为整数及元素个数小于一定范围使用 intset 编码，任意条件不满足，则使用 hashtable 编码。
5、Zset：保存的元素个数小于定值且成员长度小于定值使用 ziplist 编码，任意条件不满足，则使用 skiplist 编码。

#### 单线程
Redis采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

#### 非阻塞IO、多路IO复用模型
Redis采用多路IO复用模型，在内部采用epoll代理。多路是指多个网络连接，IO复用是指复用同一个线程。epoll会同时监察多个流的IO事件，在空闲时，当前线程进入阻塞，如果有IO事件时，线程会被唤醒，并且epoll会通知线程是哪个流发生了IO事件，然后按照顺序处理，减少了网络IO的时间消耗，避免了大量的无用操作。

#### Redis6.0后引入多线程提速：
要知道 读写网络的read/write系统耗时 >> Redis运行执行耗时，Redis的瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:
1、提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式;
2、使用多线程充分利用多核，典型的实现比如 Memcached。
协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以Redis支持多线程主要就是两个原因：
1、可以充分利用服务器 CPU 资源，目前主线程只能利用一个核;
2、多线程任务可以分摊 Redis 同步 IO 读写负荷.

关于多线程须知:
Redis 6.0 版本 默认多线程是关闭的 io-threads-do-reads no;
Redis 6.0 版本 开启多线程后 线程数也要 谨慎设置。
多线程可以使得性能翻倍，但是多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。

###  Redis常见问题
#### 缓存雪崩
雪崩定义：
缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
雪崩解决方案：
1、缓存数据的过期时间加上个随机值，防止同一时间大量数据过期现象发生。
2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3、设置热点数据永远不过期。


#### 缓存穿透
穿透定义：
缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。
穿透解决方案：
1、最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
2、后端接口层增加 用户鉴权校验，参数做校验等。
3、单个IP每秒访问次数超过阈值直接拉黑IP，关进小黑屋1天，在获取IP代理池的时候我就被拉黑过。
4、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null 失效时间可以为15秒防止恶意攻击。

#### 缓存击穿
击穿定义：
大量并发的对某个或某些设置了过期时间的热点key进行访问，当这些个Key在失效的瞬间，这时候大并发会直接到达后端数据库，在这瞬间数据库可能就会被压垮了。
击穿解决方案：
设置热点数据永远不过期 加上互斥锁也能搞定了。


#### 双写一致性
双写：缓存跟数据库均更新数据，如何保证数据一致性？
1、先更新数据库，再更新缓存
安全问题：线程A更新数据库->线程B更新数据库->线程B更新缓存->线程A更新缓存。导致脏读。
业务场景：读多写少场景，频繁更新数据库而缓存根本没用。更何况如果缓存是叠加计算后结果更浪费性能。
2、先删缓存，再更新数据库
A 请求写来更新缓存。
B 发现缓存不在去数据查询旧值后写入缓存。
A 将数据写入数据库，此时缓存跟数据库不一致。

因此 FackBook 提出了  Cache Aside Pattern
失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
命中：应用程序从cache中取数据，取到后返回。
更新：先把数据存到数据库中，成功后，再让缓存失效。


#### 脑裂
脑裂是指因为网络原因，导致master节点、slave节点 和 sentinel集群处于不用的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点 此时存在两个不同的master节点就像一个大脑分裂成了两个。其实在Hadoop 、Spark集群中都会出现这样的情况，只是解决方法不同而已(用ZK配合强制杀死)。

集群脑裂问题中，如果客户端还在基于原来的master节点继续写入数据那么新的master节点将无法同步这些数据，当网络问题解决后sentinel集群将原先的master节点降为slave节点，此时再从新的master中同步数据将造成大量的数据丢失。

Redis处理方案是redis的配置文件中存在两个参数:
`min-replicas-to-write 3  表示连接到master的最少slave数量`
`min-replicas-max-lag 10  表示slave连接到master的最大延迟时间`

如果连接到master的slave数量 < 第一个参数 且 ping的延迟时间 <= 第二个参数那么master就会拒绝写请求，配置了这两个参数后如果发生了集群脑裂则原先的master节点接收到客户端的写入请求会拒绝就可以减少数据同步之后的数据丢失。


### Redis 过期策略和内存淘汰策略

#### Redis的过期策略
Redis中 过期策略 通常有以下三种：
**1、定时过期**：
每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
**2、惰性过期**：
只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
**3、定期过期：**
每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
expires字典会保存所有设置了过期时间的key的过期时间数据，其中 key 是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。

Redis采用的过期策略：**惰性删除 + 定期删除**。memcached采用的过期策略：**惰性删除**。

#### 6种内存淘汰策略
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
```
1、volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 
2、volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 
3、volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 
4、allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 
5、allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 
6、no-enviction（驱逐）：禁止驱逐数据，不删除的意思；当内存不足以容纳新写入数据时，新写入操作会报错。
```
面试常问常考的也就是LRU了，大家熟悉的LinkedHashMap中也实现了LRU算法的，实现如下：
```
class SelfLRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int CACHE_SIZE;
    /**
     * 传递进来最多能缓存多少数据
     * @param cacheSize 缓存大小
     */
    public SelfLRUCache(int cacheSize) {
  // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
        CACHE_SIZE = cacheSize;
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。
        return size() > CACHE_SIZE;
    }
}
```

**总结：**Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据，过期策略用于处理过期的缓存数据。


###  Redis哨兵模式集群



###  Redis运维



###  Redis部分配置


###  Redis本身的性能测试

benchmark
















