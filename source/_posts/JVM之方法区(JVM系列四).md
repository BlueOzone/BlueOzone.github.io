---
title: JVM之方法区(JVM系列四)
toc: true
date: 2021-02-20 15:29:53
categories: Java
tags: Java进阶
---

## JVM整体架构
![JVM整体架构](https://github.com/BlueOzone/BlueOzone.github.io/blob/hexo/source/_posts/img/JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png?raw=true)

## 栈、堆、方法区的交互关系

![栈、堆、方法区的交互关系](https://github.com/BlueOzone/BlueOzone.github.io/blob/hexo/source/_posts/img/%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png?raw=true)

## 方法区的理解
<<Java虚拟机规范>>中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。
所以，**方法区看作是一块 独立于Java堆的内存空间。**


方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。
方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：PermGen space或者java.lang.OutOfMemoryError：Metaspace。
关闭JVM就会释放这个区域的内存。


## 设置方法区大小与OOM
jdk8及以后：
元数据区大小可以使用参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`指定。
默认值依赖于平台。Windows下，`-XX:MetaspaceSize`是21M，`-XX:MaxMetaspaceSize`的值是-1，即没有限制。
与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace。

`-XX:MetaspaceSize` 设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。
如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。

## OOM解决方式
**内存泄漏(memory leak)**:是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
**内存溢出(out of memory)**:指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。

1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）.

2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎么的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。

3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。


## 方法区的内部结构

### 方法区（Method Area）存储什么？
方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

### 类型信息
对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
1、这个类型的完整有效名称（全名=包名.类名）；
2、这个类型直接父类的完整有效名（对于interface或是java.lang.Object来讲，都没有父类）；
3、这个类型的修饰符（public，abstract，final的某个子集）；
4、这个类型直接接口的一个有序列表。

### 域(Field)信息

JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

### 方法(Method)信息
JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
方法名称
方法的返回类型(或void)
方法参数的数量和类型(按顺序)
方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的某个子集）
方法的字节码(bytecodes)、操作数栈、局部变量表及大小（abstract和native方法除外）
异常表（abstract和native方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。

### 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。
常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。

JVM为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的。
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。
运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。


## 方法区的演进细节
jdk1.6及之前：
有永久代(permanent generation)，静态变量存放在永久代上。
jdk1.7：
有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。
jdk1.8及以后：
无永久代，类型信息、字段、方法、常量、保存在本地内存的元空间，但字符串常量池、静态变量仍在堆上。

永久代为什么要被元空间替换？
(1)为永久代设置空间大小是很难确定的。
元空间不在虚拟机中，而是使用本地内存；一般情况下元空间的大小仅受本地内存限制。永久代在虚拟机中，往往不能很好的确定其大小。
(2)对永久代进行调优是很困难的。

## 方法区的垃圾回收
<<Java虚拟机规范>>中对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。
HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。
回收废弃常量与回收Java堆中的对象非常类似。
## 总结



