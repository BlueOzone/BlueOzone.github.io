<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Redis分布式锁(高级篇系列四) | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis分布式锁(高级篇系列四)</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis分布式锁(高级篇系列四)</h1><div class="post-meta">2021-04-02<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">分布式锁概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">分布式锁的几种实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">基于Redis的分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">基于单节点的Redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">实现命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">实现过程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">上面的实现过程中几个重要的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8F%AF%E8%83%BD%E6%B0%B8%E8%BF%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E9%87%8A%E6%94%BE"><span class="toc-number">4.3.1.</span> <span class="toc-text">锁可能永远得不到释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.</span> <span class="toc-text">获取锁的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E9%94%81%E8%AE%BE%E7%BD%AE%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.3.</span> <span class="toc-text">给锁设置唯一字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.4.</span> <span class="toc-text">释放锁的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">单节点Redis分布式锁无法解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">4.5.</span> <span class="toc-text">有效时间问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedLock%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">RedLock算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redlock%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">Redlock算法的安全性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%87%8D%E5%90%AF"><span class="toc-number">5.2.</span> <span class="toc-text">延迟重启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">释放锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redission"><span class="toc-number">6.</span> <span class="toc-text">Redission</span></a></li></ol></div></div><div class="post-content"><h2 id="分布式锁概述"><a href="#分布式锁概述" class="headerlink" title="分布式锁概述"></a>分布式锁概述</h2><p><strong>分布式锁</strong>，是控制分布式系统之间<strong>同步访问共享资源</strong>的一种方式。</p>
<p>在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要<strong>互斥</strong>来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</p>
<h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><ul>
<li>基于MySQL的分布式锁</li>
<li>基于Redis的分布式锁</li>
<li>基于ZooKeeper的分布式锁</li>
<li>自研分布式锁:如谷歌的Chubby</li>
</ul>
<p>本文介绍的是基于Redis的分布式锁。</p>
<h2 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h2><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。 </p>
<p>占坑一般是使用 <code>setnx(set if not exists)</code> 指令，只允许被一个客户端占坑。先来先占，用完了，再调用<code>del</code>指令释放茅坑。</p>
<p>常规的基于Redis的分布式锁方案，用的Redis都是单节点的，但是单节点的有一种无法解决的问题（后面会讲到），基于这个问题，Redis的作者提供了一种通用的算法Redlock，他认为这种算法实现比普通的单节点实现更安全；下面我们一一来了解单节点的Redis分布式锁和Redlock算法。</p>
<h2 id="基于单节点的Redis分布式锁"><a href="#基于单节点的Redis分布式锁" class="headerlink" title="基于单节点的Redis分布式锁"></a>基于单节点的Redis分布式锁</h2><h3 id="实现命令"><a href="#实现命令" class="headerlink" title="实现命令"></a>实现命令</h3><p>我们先来看下正确的操作步骤，基于单节点的Redis分布式锁主要利用下面这条命令：</p>
<p><code>SET key_name my_random_value NX PX 30000</code></p>
<h3 id="实现过程简述"><a href="#实现过程简述" class="headerlink" title="实现过程简述"></a>实现过程简述</h3><p>首先，Redis客户端为了<strong>获取锁</strong>，向Redis节点发送上面这条命令，上面的命令如果执行成功，则代表客户端成功获取到了锁，接下来就可以<strong>访问共享资源</strong>了；而如果上面的命令执行失败，则说明获取锁失败。</p>
<p>客户端获取到锁，完成了对共享资源的操作之后，然后需要去<strong>释放锁</strong>。</p>
<p>在上面的<code>SET</code>命令中：</p>
<ul>
<li><code>my_random_value</code>是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li>
<li><code>NX</code>表示只有当<code>key_name</code>对应的key值不存在的时候才能<code>SET</code>成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li>
<li><code>PX 30000</code>表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，大家可以根据业务情况选择合适的过期时间。</li>
</ul>
<p>最后，当客户端完成了对共享资源的操作之后，需要执行下面的Redis Lua脚本来<strong>释放锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段Lua脚本在执行的时候要把前面的<code>my_random_value</code>作为<code>ARGV[1]</code>的值传进去，把<code>key_name</code>作为<code>KEYS[1]</code>的值传进去。</p>
<h3 id="上面的实现过程中几个重要的问题"><a href="#上面的实现过程中几个重要的问题" class="headerlink" title="上面的实现过程中几个重要的问题"></a>上面的实现过程中几个重要的问题</h3><h4 id="锁可能永远得不到释放"><a href="#锁可能永远得不到释放" class="headerlink" title="锁可能永远得不到释放"></a>锁可能永远得不到释放</h4><p>第一个问题，这个锁必须要设置一个过期时间。否则的话，当一个客户端获取锁成功之后，假如执行业务操作时它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p>
<h4 id="获取锁的操作"><a href="#获取锁的操作" class="headerlink" title="获取锁的操作"></a>获取锁的操作</h4><p>第二个问题，获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br></pre></td></tr></table></figure>

<p>虽然这两个命令和前面算法描述中的一个<code>SET</code>命令执行效果相同，但却不是原子的。如果客户端在执行完<code>SETNX</code>后崩溃了，那么就没有机会执行<code>EXPIRE</code>了，导致它一直持有这个锁。Redis 2.8 版本中作者加入了<code>SET</code>指令的扩展参数（如上所示），使得 <code>SETNX</code>和<code>EXPIRE</code>指令可以一起执行。</p>
<h4 id="给锁设置唯一字符串"><a href="#给锁设置唯一字符串" class="headerlink" title="给锁设置唯一字符串"></a>给锁设置唯一字符串</h4><p>第三个问题，设置一个随机字符串<code>my_random_value</code>是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。假如获取锁时<code>SET</code>的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p>
<ol>
<li>客户端1获取锁成功。</li>
<li>客户端1在某个操作上阻塞了很长时间。</li>
<li>过期时间到了，锁自动释放了。</li>
<li>客户端2获取到了对应同一个资源的锁。</li>
<li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li>
</ol>
<p>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了；所以必须保证了一个客户端释放的锁必须是自己持有的那个锁。</p>
<h4 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h4><p>第四个问题，释放锁的操作必须使用<strong>Lua脚本</strong>来实现。我们上面说到，必须给锁设置唯一的字符串，保证客户端释放的锁必须是自己持有的那个锁。</p>
<p>这样释放锁其实包含三步操作：<code>GET</code>锁的唯一字符串、判断是否匹配和<code>DEL</code>锁，需要用Lua脚本来实现能保证这三步的原子性。否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p>
<ol>
<li>客户端1获取锁成功。</li>
<li>客户端1访问共享资源。</li>
<li>客户端1为了释放锁，先执行<code>GET</code>操作获取随机字符串的值。</li>
<li>客户端1判断随机字符串的值，与预期的值相等。</li>
<li>客户端1由于某个原因阻塞住了很长时间。</li>
<li>过期时间到了，锁自动释放了。</li>
<li>客户端2获取到了对应同一个资源的锁。</li>
<li>客户端1从阻塞中恢复过来，执行<code>DEL</code>操纵，释放掉了客户端2持有的锁。</li>
</ol>
<p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p>
<h3 id="单节点Redis分布式锁无法解决的问题"><a href="#单节点Redis分布式锁无法解决的问题" class="headerlink" title="单节点Redis分布式锁无法解决的问题"></a>单节点Redis分布式锁无法解决的问题</h3><p>前面的四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。但除此之外，Redis的作者antirez还指出了一个问题，是由failover引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p>
<p>这个问题是这样的。假如单节点Redis宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。考虑下面的执行序列：</p>
<ol>
<li>客户端1从Master获取了锁。</li>
<li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li>
<li>Slave升级为Master。</li>
<li>客户端2从新的Master获取到了对应同一个资源的锁。</li>
</ol>
<p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。针对这个问题，Redis的作者antirez设计了Redlock算法。</p>
<h3 id="有效时间问题"><a href="#有效时间问题" class="headerlink" title="有效时间问题"></a>有效时间问题</h3><p>另外，前面这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？</p>
<p>如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。</p>
<p>所以分布式锁的选择也要看具体的业务场景来具体操作。</p>
<h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>由于前面介绍的基于单Redis节点的分布式锁在故障切换的时候会产生解决不了的安全性问题，因此Redis的作者antirez提出了新的一种通用的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p>
<p>运行Redlock算法的客户端依次执行下面各个步骤，来完成<strong>获取锁</strong>的操作：</p>
<ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向N个Redis节点执行<strong>获取锁</strong>的操作。这个获取操作跟前面基于单Redis节点的<strong>获取锁</strong>的过程相同，包含随机字符串<code>my_random_value</code>，也包含过期时间(比如<code>PX 30000</code>，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个<strong>获取锁</strong>的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</li>
<li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从<strong>大多数Redis节点（&gt;= N/2+1）</strong>成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为<strong>最终获取锁成功</strong>；否则，认为最终获取锁失败。</li>
<li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它<strong>等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间</strong>。</li>
<li>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起<strong>释放锁</strong>的操作（即前面介绍的Redis Lua脚本）。</li>
</ol>
<p>当然，上面描述的只是<strong>获取锁</strong>的过程，而<strong>释放锁</strong>的过程比较简单：客户端向所有Redis节点发起<strong>释放锁</strong>的操作，不管这些节点当时在获取锁的时候成功与否。</p>
<h3 id="Redlock算法的安全性问题"><a href="#Redlock算法的安全性问题" class="headerlink" title="Redlock算法的安全性问题"></a>Redlock算法的安全性问题</h3><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。</p>
<p>具体的影响程度跟Redis对数据的持久化程度有关。</p>
<p>假设一共有5个Redis节点：A, B, C, D, E；设想发生了如下的事件序列：</p>
<ol>
<li>客户端1成功锁住了A, B, C，<strong>获取锁</strong>成功（但D和E没有锁住）。</li>
<li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li>
<li>节点C重启后，客户端2锁住了C, D, E，<strong>获取锁</strong>成功。</li>
</ol>
<p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p>
<p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。</p>
<h3 id="延迟重启"><a href="#延迟重启" class="headerlink" title="延迟重启"></a>延迟重启</h3><p>为了应对上面这个问题，antirez又提出了<strong>延迟重启</strong>(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>在最后<strong>释放锁</strong>的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起<strong>释放锁</strong>的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p>
<p>设想这样一种情况，客户端发给某个Redis节点的<strong>获取锁</strong>的请求成功到达了该Redis节点，这个节点也成功执行了<code>SET</code>操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。</p>
<p>实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p>
<h2 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h2><p>Redission是Java语言实现的Redis客户端，是一个在Redis的基础上实现的Java驻内存数据网格。Redission底层采用的是netty框架，在分布式锁的实现上也提供了Redlock算法的实现。所以现在做基于Redis的分布式锁的话可以用Redission来实现。</p>
</div><div class="tags"><a href="/tags/Redis%E9%AB%98%E7%BA%A7/"><i class="fa fa-tag"></i>Redis高级</a></div><div class="post-nav"><a class="pre" href="/2021/05/12/docker/">Docker的基本使用</a><a class="next" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis%E9%AB%98%E7%BA%A7/" style="font-size: 15px;">Redis高级</a> <a href="/tags/Redis%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Redis基础</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/" style="font-size: 15px;">等级保护</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/docker/">Docker的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E5%9B%9B)/">Redis分布式锁(高级篇系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/Redis%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%B8%89)/">Redis保证原子性(高级篇系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/01/JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80(%E7%B3%BB%E5%88%97%E4%BA%94)/">JVM之对象的内存布局(系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA(%E7%B3%BB%E5%88%97%E5%9B%9B)/">JVM之方法区(系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM%E4%B9%8B%E5%A0%86(%E7%B3%BB%E5%88%97%E4%B8%89)/">JVM之堆(系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B(%E7%B3%BB%E5%88%97%E4%BA%8C)/">JVM之运行时数据区(系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F(%E7%B3%BB%E5%88%97%E4%B8%80)/">JVM之类加载子系统(系列一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/13/Python%E5%9C%A8Linux%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/">Python实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/Redis%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6(%E9%AB%98%E7%BA%A7%E7%AF%87%E7%B3%BB%E5%88%97%E4%BA%8C)/">Redis的常见问题(高级篇系列二)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>