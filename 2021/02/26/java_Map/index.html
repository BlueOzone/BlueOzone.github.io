<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java-Map之HashMap | 雨落花下c</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-Map之HashMap</h1><a id="logo" href="/.">雨落花下c</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-Map之HashMap</h1><div class="post-meta">2021-02-26<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">1.</span> <span class="toc-text">Map概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">2.</span> <span class="toc-text">Map的实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">3.</span> <span class="toc-text">HashMap的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">4.</span> <span class="toc-text">Map中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">5.</span> <span class="toc-text">线程安全的几种Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">5.1.</span> <span class="toc-text">ConcurrentHashMap - 推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">5.2.</span> <span class="toc-text">SynchronizedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">5.3.</span> <span class="toc-text">HashTable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">6.</span> <span class="toc-text">Map相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.1.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.2.</span> <span class="toc-text">HashMap 和 HashSet 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.3.</span> <span class="toc-text">HashSet 如何检查重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.4.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.5.</span> <span class="toc-text">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">6.6.</span> <span class="toc-text">HashMap遍历方式</span></a></li></ol></li></ol></div></div><div class="post-content"><h2><span id="map概述">Map概述</span></h2><p>Map 提供了一个更通用的元素存储方法。<br>Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。<a id="more"></a></p>
<h2><span id="map的实现类">Map的实现类</span></h2><p>① HashMap：作为Map的主要实现类；无序的，<strong>线程不安全</strong>的，效率高；可以存储null的key和value。<br>② LinkedHashMap extends HashMap：有序的；保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。<br>③ TreeMap：保证按照添加的key-value键值对进行排序，实现排序遍历。此时key的自然排序或定制排序；底层使用红黑树存储。<br>④ Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value。<br>⑤ Properties extends Hashtable：常用来处理配置文件。key和value都是String类型。</p>
<h2><span id="hashmap的底层实现原理">HashMap的底层实现原理</span></h2><p>首先以jdk7为例说明：<br><code>HashMap map = new HashMap();</code>执行后：<br>底层创建了长度是16的一维数组<code>Entry[] table</code>。<br><code>map.put(key1,value1);</code>执行后：<br><img src="https://github.com/BlueOzone/BlueOzone.github.io/blob/hexo/source/_posts/img/HashMap%E8%B0%83%E7%94%A8put%E6%96%B9%E6%B3%95%E8%BF%87%E7%A8%8B.png?raw=true" alt="HashMap调用put方法过程"></p>
<p>在不断的添加过程中，会涉及扩容问题，当超出临界值（且要存放的位置非空）时，会扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有数据复制过来。</p>
<p>jdk8 相较于jdk7在底层实现方面的不同：<br>（1）new HashMap()：底层并没有直接创建一个长度为16的数组；而是等到第一次put()的时候才会创建；<br>（2）jdk 8底层的数组是：Node[]，而非Entry[]；<br>（3）首次调用put()方法时，底层才创建长度为16的数组；<br>（4）jdk 7底层结构只有：数组+链表；jdk 8中底层结构：数组+链表+红黑树。<br>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64 时，<br>此时此索引位置上的所有数据会改为使用红黑树存储。</p>
<p><code>DEFAULT_INITIAL_CAPACITY</code>：HashMap的默认容量：16<br><code>DEFAULT_LOAD_FACTOR</code>：HashMap的默认加载因子：0.75<br><code>threadold</code>：扩容的临界值=容量*填充因子：16*0.75 = 12<br><code>TREEIFY_THRESHOLD</code>：Bucket中链表长度大于该默认值，转化为红黑树：8<br><code>MIN_TREEIFY_CAPACITY</code>：桶中的Node被树化时最小的hash表容量：64</p>
<p>以下附上HashMap部分源码及其解析：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层使用的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的默认容量：16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的默认加载因子：0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bucket中链表长度大于该默认值，转化为红黑树：8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶中的Node被树化时最小的hash表容量：64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//put方法</span></span><br><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">	<span class="comment">//计算key的hash值传入putVal方法</span></span><br><span class="line">	<span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">	<span class="built_in">int</span> h;</span><br><span class="line">	<span class="comment">//hash值计算方法</span></span><br><span class="line">	<span class="comment">//若key==null，hash=0;</span></span><br><span class="line">	<span class="comment">//key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值，然后做一次16位右位移异或混合计算得出hash值；</span></span><br><span class="line">	<span class="comment">//右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">               <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    <span class="keyword">HashMap</span>.Node&lt;K,V&gt;[] tab; <span class="keyword">HashMap</span>.Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">//tab = table;判断当前table数组是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//若为空，调用resize方法，table为空时resize返回一个初始化过后的数组，长度为16</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过哈希值计算索引值，判断数组上该索引上是否有值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//若为null，则直接插入新的数据</span></span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//若以上条件不满足，则需要比较hash值和key值是否相等</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>.Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//先判断p处的hash值和传进来的hash值、再判断p.key和传进来的key的地址值是否相等、再通过equals方法判断两者的值是否相等</span></span><br><span class="line">        <span class="comment">//注意第一个逻辑与后面的条件，若地址值都相等了就不需要equals判断了</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="comment">//将p指向的地址赋给e;</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断p处是否使用红黑树存储</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> <span class="keyword">HashMap</span>.TreeNode)</span><br><span class="line">            e = ((<span class="keyword">HashMap</span>.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">        <span class="comment">//若以上条件不满足，进入以下</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断node节点p是否存在下一个元素，即使判断p.next是否为空</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//若p.next为空，则把新的元素放到p.next里，原本的值还在数组索引的第一处</span></span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//判断链表长度，决定是否使用红黑树存储；若大于TREEIFY_THRESHOLD-1，则使用红黑树进行存储</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">//跳出循环，e=p.next;</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先判断e=p.next处的hash值和传进来的hash值、再判断e.key和传进来的key的地址值是否相等、再通过equals方法判断两者的值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="comment">//若相等，跳出循环,e=p.next</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//若以上条件不符合，则p=e;即p = p.next;</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过以上条件后，判断e是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//若不为空，取出e的value值给变量oldValue;</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//更新e的value值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回旧的value值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//添加新元素后，判断++size是否大于临界值</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        <span class="comment">//若大于临界值，调用resize()扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="map中的方法">Map中的方法</span></h2><p><strong>添加、删除、修改操作：</strong><br>Object put(Object key,Object value)：将指定的key-value添加到（或修改到）当前map对象中<br>void putAll(Map m)：将m中的所有key-value复制到当前map中<br>Object remove(Object key)：移除指定key的key-value数据，并返回value<br>void clear()：清空当前map的所有数据<br><strong>元素查询的操作：</strong><br>Object get(Object key)：获取指定key对应的value<br>boolean containsKey(Object key)：map对象中是否包含指定的key<br>boolean containsValue(Object value)：map对象中是否包含指定的value<br>int Size()：返回当前map中key-value键值对的个数<br>boolean isEmpty()：判断当前map是否为空<br>boolean equals(Object obj)：判断当前map和参数obj是否相等</p>
<p><strong>元视图操作的方法：</strong><br>Set keySet()：返回所有key构成的Set集合<br>Collection values()：返回所有value构成的Collection集合<br>Set entrySet()：返回所有key-value键值对构成的Set集合</p>
<h2><span id="线程安全的几种map">线程安全的几种Map</span></h2><h3><span id="concurrenthashmap-推荐">ConcurrentHashMap - 推荐</span></h3><ul>
<li>当你程序需要高度的并行化的时候，你应该使用ConcurrentHashMap；</li>
<li>尽管没有同步整个Map，但是它仍然是线程安全的；</li>
<li>读操作非常快，而写操作则是通过加锁完成的；</li>
<li>在对象层次上不存在锁（即不会阻塞线程）；</li>
<li>锁的粒度设置的非常好，只对哈希表的某一个key加锁；</li>
<li>ConcurrentHashMap不会抛出ConcurrentModificationException，即使一个线程在遍历的同时，另一个线程尝试进行修改；</li>
<li>ConcurrentHashMap会使用多个锁。</li>
</ul>
<h3><span id="synchronizedmap">SynchronizedMap</span></h3><p>这种是直接使用工具类里面的方法创建SynchronizedMap，把传入进行的HashMap对象进行了包装同步。<br>用法：<br><code>Map&lt;String, Object&gt; map22 = Collections.synchronizedMap(new HashMap&lt;String, Object&gt;());</code></p>
<ul>
<li>会同步整个对象；</li>
<li>每一次的读写操作都需要加锁；</li>
<li>对整个对象加锁会极大降低性能；</li>
<li>这相当于只允许同一时间内至多一个线程操作整个Map，而其他线程必须等待；</li>
<li>它有可能造成资源冲突（某些线程等待较长时间）；</li>
<li>SynchronizedHashMap会返回Iterator，当遍历时进行修改会抛出异常。</li>
</ul>
<h3><span id="hashtable">HashTable</span></h3><p>HashTable作为古老的实现类；线程安全的，效率低；不能存储null的key和value。<br>用法：<code>Map&lt;String, Object&gt; map33 = new Hashtable&lt;&gt;();</code><br>通过查阅HashTable的源码可以知道，HashTable初始化的容量是11，加载因子为0.75：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> * Constructs a new, empty hashtable with a default initial capacity (11)</span><br><span class="line"> * and load factor (0.75).</span><br><span class="line"> */</span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续查看HashTable的源码发现，get/put方法都被synchronized关键字修饰，说明它们是方法级别阻塞的，它们占用共享资源锁，所以导致同时只能一个线程操作get或者put，而且get/put操作不能同时执行，所以这种同步的集合效率非常低，一般不建议使用这个集合。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.<span class="built_in">key</span>.equals(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, <span class="built_in">key</span>, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="map相关面试题">Map相关面试题</span></h2><h3><span id="hashmap-和-hashtable-的区别">HashMap 和 Hashtable 的区别</span></h3><p>（1）<strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；<br>（2）<strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；<br>（3）<strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。<br>（4）<strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。<br>（5）<strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
<h3><span id="hashmap-和-hashset-区别">HashMap 和 HashSet 区别</span></h3><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<h3><span id="hashset-如何检查重复">HashSet 如何检查重复</span></h3><p>由于HashSet 底层就是基于 HashMap 实现的，所以根据前面的put()流程图可以知道：<br>当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
<p><strong>hashCode()与 equals() 的相关规定：</strong></p>
<p>（1）如果两个对象相等，则 hashcode 一定也是相同的；<br>（2）两个对象相等,对两个 equals() 方法返回 true；<br>（3）两个对象有相同的 hashcode 值，它们也不一定是相等的；<br>（4）综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖；<br>（5）hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<p><strong>==与 equals 的区别</strong></p>
<p>对于基本类型来说，== 比较的是值是否相等；<br>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；<br>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h3><span id="concurrenthashmap-和-hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</span></h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h3><span id="concurrenthashmap-线程安全的具体实现方式底层具体实现">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</span></h3><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h3><span id="hashmap遍历方式">HashMap遍历方式</span></h3><p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p>
<p>（1）迭代器（Iterator）方式遍历；<br>（2）For Each 方式遍历；<br>（3）Lambda 表达式遍历（JDK 1.8+）；<br>（4）Streams API 遍历（JDK 1.8+）。</p>
</div><div class="tags"><a href="/tags/Java基础/"><i class="fa fa-tag"></i>Java基础</a></div><div class="post-nav"><a class="pre" href="/2021/02/26/java_IO流/">Java-IO流</a><a class="next" href="/2021/02/26/java_反射/">Java-反射</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/等级保护/">等级保护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java进阶/" style="font-size: 15px;">Java进阶</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/Redis技术/" style="font-size: 15px;">Redis技术</a> <a href="/tags/等级保护/" style="font-size: 15px;">等级保护</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/java_IO流/">Java-IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/java_Map/">Java-Map之HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/java_反射/">Java-反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/java_多线程/">Java-多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/redis初识/">Redis初识(基本理论)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM之方法区(JVM系列四)/">JVM之方法区(JVM系列四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JVM之对象的实例化内存布局与访问定位(JVM系列五)/">JVM之对象的实例化内存布局与访问定位(JVM系列五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/JVM之堆(JVM系列三)/">JVM之堆(JVM系列三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/21/JVM之运行时数据区概述及线程(JVM系列二)/">JVM之运行时数据区概述及线程(JVM系列二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/19/JVM之类加载子系统(JVM系列一)/">JVM之类加载子系统(JVM系列一)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">雨落花下c.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>